name: "Fake voicemail notification (untrusted sender)"
description: |
  This rule detects a common credential phishing vector enticing the user to engage with links under the premise that they have a voicemail to retrieve.
  The rule looks for voicemail verbiage in the display name, body, subject or a combination of those elements with emojis or a medium to high credential theft NLU Intent from first-time + unsolicited sender.
type: "rule"
severity: "medium"
source: "type.inbound\nand length(body.links) <= 20\n// the subject, display_name or current_thread need some keywords which are voicemail related\nand (\n  any([subject.subject, sender.display_name, body.current_thread.text],\n      regex.icontains(.,\n                      '(v[nm]?|voice|audio|call\\b|missed(\\sa\\s)?|left a|caii|phone)(\\s?|-)(mail|message|msg|recording|notif|support|call\\d*\\b|caii)|transcript(ion)?|open mp3|audio note|playback|\\.wav'\n      )\n      // filter out topics that mention audio and listening, but are not voicemails\n      and not any([\n                    \"podcast\",\n                    \"tune\",\n                    \"album\",\n                    \"episode\",\n                    \"study\",\n                    \"series\",\n                    \"coach\",\n                    \"voice features\"\n                  ],\n                  strings.icontains(.., .)\n      )\n  )\n  or \n  // don't do phone number detection in the body, only within the subject or display name \n  any([subject.subject, sender.display_name],\n      regex.icontains(.,\n                      // obfuscated phone number\n                      '\\(?(\\d{3}|\\d{2}\\*|\\d\\*{2})\\)?[^a-z0-9]{0,2}(\\d{3}|\\d{2}\\*|\\d\\*{2}|\\*{3})[^a-z0-9]{0,2}(\\d{3}\\*|\\d{2}\\*{2}|\\d\\*{3}|\\*{4})',\n                      // non-obufscated number\n                      '\\(?\\d{3}\\)?[-\\s_\\.]\\d{3}[-\\s_\\.]\\d{4}\\b'\n      )\n  )\n)\nand 2 of (\n  (\n    // the sender is a freemail\n    sender.email.domain.root_domain in $free_email_providers\n  ),\n  (\n    any(ml.nlu_classifier(body.current_thread.text).intents,\n        .name in (\"cred_theft\") and .confidence in (\"medium\", \"high\")\n    )\n  ),\n  (\n    any(attachments,\n        .content_type in (\"html\", \"text\", \"text/html\")\n        and any(ml.logo_detect(file.html_screenshot(.)).brands,\n                .name in (\"Microsoft\") and .confidence in (\"medium\", \"high\")\n        )\n    )\n  ),\n  (\n    regex.icontains(sender.display_name,\n                    '(voice|audio|call|missed|caii)(\\s?|-)(mail|message|recording|call|caii)|transcription'\n    )\n  ),\n  // attachment names are often HTML and voice mail related\n  (\n    any(attachments,\n        (\n          .content_type in (\"html\", \"text\", \"text/html\")\n          or .file_type in (\"html\", \"unknown\")\n        )\n        and (\n          regex.icontains(.file_name,\n                          '(?:voice|audio|call|missed|caii|mail|message|recording|call|caii|transcription|v[nm]|audio|play|listen|unheard|msg)',\n                          // contains a time\n                          // 01min , 60secs\n                          '0?[1-9]\\s*min(?:(?:ute)?s)?',\n                          '\\d{1,2}\\s*s(?:ec(?:ond)?s)?',\n                          // (00:50s)\n                          // 3:26 seconds\n                          '[\\(\\[]?(?:\\d{1,2}[\\:\\s-])\\d{1,2}[\\)\\]]?\\s*(?:s(?:(?:ecs?)onds)?)[\\)\\]]?',\n                          // 03min25secs\n                          '0?[1-9]\\s*min(?:(?:ute)?s)?\\d{1,2}\\s*s(?:ec(?:ond)?s)?',\n                          // [0:39] \n                          // (0:39) \n                          '[\\(\\[](?:\\d{1,2}[\\:\\s-])\\d{1,2}[\\)\\]]\\s',\n                          // contains an emoji\n                          '[\\x{1F300}-\\x{1F5FF}\\x{1F600}-\\x{1F64F}\\x{1F680}-\\x{1F6FF}\\x{1F700}-\\x{1F77F}\\x{1F780}-\\x{1F7FF}\\x{1F900}-\\x{1F9FF}\\x{2600}-\\x{26FF}\\x{2700}-\\x{27BF}\\x{2300}-\\x{23FF}]'\n          )\n          // somtimes there is no name, it's just the extension which is also strange\n          or .file_name in~ (\".htm\", \".html\")\n          // or sometimes it has no name....\n          or .file_name is null\n          or any(recipients.to,\n                 // the html attachment contains a receipient email address\n                 strings.contains(file.parse_html(..).raw, .email.email)\n                 // the sld of the domain is in the attachment name\n                 or strings.contains(..file_name, .email.domain.sld)\n          )\n        )\n    )\n  ),\n  // the body links contain the recipients email\n  (\n    length(filter(recipients.to, .email.email != \"\" or .email.domain.valid)) > 0\n    and any(body.links,\n            any(recipients.to,\n                strings.icontains(..href_url.url, .email.email)\n                or strings.icontains(..href_url.url, .email.local_part)\n            )\n    )\n  ),\n  (\n    length(body.current_thread.text) < 700\n    and regex.icontains(body.current_thread.text,\n                        'Méssãge|Méssage|Recéived|Addréss'\n    )\n  ),\n  (\n    // sender domain matches no body domains\n    // only inspect \"links\" that have a display_text and display_url is null to remove \"plain text\" email address from being caught\n    length(filter(body.links,\n                  .display_text is not null and .display_url.url is null and .href_url.domain.valid\n           )\n    ) > 0\n    and all(filter(body.links,\n                   .display_text is not null and .display_url.url is null and .href_url.domain.valid\n            ),\n            .href_url.domain.root_domain != sender.email.domain.root_domain\n            and .href_url.domain.root_domain not in $org_domains\n            and .href_url.domain.root_domain not in (\n              \"unitelvoice.com\",\n              \"googleapis.com\",\n              \"dialmycalls.com\",\n              \"ringcentral.biz\"\n            )\n    )\n  ),\n  // the body links contain vm related phrases\n  (\n    any(body.links,\n        regex.contains(.display_text, '[^a-z]*[A-Z][^a-z]*')\n        and regex.icontains(.display_text,\n                            '(v[nm]|voice|audio|call|missed|caii)(\\s?|-)(mail|message|recording|call|caii)|transcription|open mp3|audio note|listen|playback|\\(?(?:\\*\\*\\*|[0-9]{3})?.(?:\\*\\*\\*|[0-9]{3})[^a-z]{0,2}(?:\\*{4}|\\d+\\*+)|play'\n        )\n        // negate FP terms in link display texts\n        and not strings.icontains(.display_text, 'voice call center')\n    )\n  ),\n  (\n    any(body.links,\n        .href_url.path == \"/ctt\"\n        and regex.icontains(.display_text,\n                            '(v[nm]|voice|audio|call|missed|caii)(\\s?|-)(mail|message|recording|call|caii)|transcription|open mp3|audio note|listen|playback|\\(?(?:\\*\\*\\*|[0-9]{3})?.(?:\\*\\*\\*|[0-9]{3})[^a-z]{0,2}(?:\\*{4}|\\d+\\*+)|play'\n        )\n        // negate FP terms in link display texts\n        and not strings.icontains(.display_text, 'voice call center')\n    )\n  ),\n  // new domains\n  (\n    any(body.links,\n        network.whois(.href_url.domain).days_old < 10\n        and not strings.icontains(.href_url.path, \"unsubscribe\")\n    )\n  ),\n  (\n    any(recipients.to,\n        // recipient's SLD is in the sender's display name\n        strings.icontains(sender.display_name, .email.domain.sld)\n        // recipient's SLD is in the sender's display name\n        or strings.icontains(subject.subject, .email.domain.sld)\n    )\n  ),\n  // often times the subject or sender display name will contain time references\n  (\n    any([sender.display_name, subject.subject, body.current_thread.text],\n        regex.icontains(.,\n                        // 01min , 60secs\n                        '0?[1-9]\\s*min(?:(?:ute)?s)?\\b',\n                        '\\d{1,2}\\s*s(?:ec(?:ond)?s)?\\b',\n                        // (00:50s)\n                        // 3:26 seconds\n                        '[\\(\\[]?(?:\\d{1,2}[\\:\\s-])\\d{1,2}[\\)\\]]?\\s*(?:s(?:(?:ecs?)onds)?)[\\)\\]]?',\n                        // 03min25secs\n                        '0?[1-9]\\s*min(?:(?:ute)?s)?\\d{1,2}\\s*s(?:ec(?:ond)?s)?',\n                        // [0:39] \n                        // (0:39) \n                        '[\\(\\[](?:\\d{1,2}[\\:\\s-])\\d{1,2}[\\)\\]]\\s'\n        )\n    )\n  ),\n  // often times the subject or sender display name will contain dates\n  (\n    any([sender.display_name, subject.subject],\n        // days of week\n        any([\n              'monday',\n              'tuesday',\n              'wednesday',\n              'thursday',\n              'friday',\n              'saturday',\n              'sunday'\n            ],\n            strings.icontains(.., .)\n        )\n        // months\n        or any([\n                 \"January\",\n                 \"February\",\n                 \"March\",\n                 \"April\",\n                 \"May\",\n                 \"June\",\n                 \"July\",\n                 \"August\",\n                 \"September\",\n                 \"October\",\n                 \"November\",\n                 \"December\"\n               ],\n               strings.icontains(.., .)\n        )\n        // common date formats\n        or regex.contains(.,\n                          // YYYY-MM-DD or YY-MM-DD (ISO 8601 format)\n                          '\\d{2}(\\d{2})?-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])',\n                          // MM/DD/YYYY or MM/DD/YY (US format)\n                          '(0[1-9]|1[0-2])/(0[1-9]|[12]\\d|3[01])/\\d{2}(\\d{2})?',\n                          // DD/MM/YYYY or DD/MM/YY (European format)\n                          '(0[1-9]|[12]\\d|3[01])/(0[1-9]|1[0-2])/\\d{2}(\\d{2})?',\n                          // Month DD, YYYY or Month DD, YY (e.g., March 15, 2024 or March 15, 24)\n                          '(January|February|March|April|May|June|July|August|September|October|November|December) (0[1-9]|[12]\\d|3[01]), \\d{2}(\\d{2})?'\n        )\n        // common time formats\n        or regex.contains(.,\n                          // Example: 23:45, 08:30\n                          '([01]\\d|2[0-3]):([0-5]\\d)',\n                          // Example: 23:45:59, 08:30:12\n                          '([01]\\d|2[0-3]):([0-5]\\d):([0-5]\\d)',\n                          // Example: 08:30 AM, 12:45 pm\n                          '(0[1-9]|1[0-2]):([0-5]\\d)\\s?([AaPp][Mm])',\n                          // Example: 08:30 AM, 12:45 pm\n                          '(0[1-9]|1[0-2]):([0-5]\\d):([0-5]\\d) ?([AaPp][Mm])'\n        )\n    )\n  ),\n  // there are often emoji in the sender display name\n  (\n    any([sender.display_name, subject.subject],\n        // contains an emoji\n        regex.contains(.,\n                       '[\\x{1F300}-\\x{1F5FF}\\x{1F600}-\\x{1F64F}\\x{1F680}-\\x{1F6FF}\\x{1F700}-\\x{1F77F}\\x{1F780}-\\x{1F7FF}\\x{1F900}-\\x{1F9FF}\\x{2600}-\\x{26FF}\\x{2700}-\\x{27BF}\\x{2300}-\\x{23FF}]'\n        )\n        // negate where the emoji occur in tags\n        and not regex.contains(.,\n                               '^(?:\\[[^\\]]*\\]\\s*)*\\[[^\\]]*[\\x{1F300}-\\x{1F5FF}\\x{1F600}-\\x{1F64F}\\x{1F680}-\\x{1F6FF}\\x{1F700}-\\x{1F77F}\\x{1F780}-\\x{1F7FF}\\x{1F900}-\\x{1F9FF}\\x{2600}-\\x{26FF}\\x{2700}-\\x{27BF}\\x{2300}-\\x{23FF}][^\\]]*\\]'\n        )\n    )\n  ),\n  // an attachment is a pdf or image that contains a url\n  (\n    1 <= length(attachments) <= 2\n    and any(attachments,\n            (.file_type in $file_types_images or .file_type == \"pdf\")\n            and any(file.explode(.),\n                    .scan.qr.type == \"url\"\n                    or strings.icontains(.scan.qr.data, 'http')\n                    or any(recipients.to,\n                           strings.icontains(..scan.qr.data, .email.local_part)\n                           or strings.icontains(..scan.qr.data, .email.email)\n                    )\n            )\n    )\n  )\n)\n\n// negating legit replies and legitimate audio file attachments and known voicemail senders\nand not (\n  sender.email.domain.valid\n  and sender.email.domain.root_domain in (\n    \"magicjack.com\",\n    \"unitelvoice.com\",\n    \"voipinterface.net\",\n    \"ringcentral.biz\",\n    \"verizonwireless.com\",\n    \"t-mobile.com\"\n  )\n)\nand not any(attachments, strings.starts_with(.content_type, \"audio\"))\nand not (\n  (\n    strings.istarts_with(subject.subject, \"RE:\")\n    // out of office auto-reply\n    // the NLU model will handle these better natively soon\n    or strings.istarts_with(subject.subject, \"Automatic reply:\")\n  )\n  and (\n    length(headers.references) > 0\n    or any(headers.hops, any(.fields, strings.ilike(.name, \"In-Reply-To\")))\n  )\n)\nand (\n  (\n    profile.by_sender().prevalence in (\"new\", \"outlier\")\n    and not profile.by_sender().solicited\n  )\n  or (\n    profile.by_sender().any_messages_malicious_or_spam\n    and not profile.by_sender().any_false_positives\n  )\n)\n// negate highly trusted sender domains unless they fail DMARC authentication\nand (\n  (\n    sender.email.domain.root_domain in $high_trust_sender_root_domains\n    and not headers.auth_summary.dmarc.pass\n  )\n  or sender.email.domain.root_domain not in $high_trust_sender_root_domains\n)\n"
attack_types:
  - "Credential Phishing"
tactics_and_techniques:
  - "Social engineering"
detection_methods:
  - "Content analysis"
  - "Natural Language Understanding"
  - "Sender analysis"
  - "URL analysis"
id: "74ba7787-e543-5ce8-b6eb-e1ecdb8f1d67"
testing_pr: 1922
testing_sha: 217f9116e7c09332b134b2f11495056e02815535
